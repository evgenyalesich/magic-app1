# –ú–∞—Ä—à—Ä—É—Ç—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ Telegram
import logging
from typing import Dict, Any

from fastapi import APIRouter, Depends, HTTPException, Response, Cookie
from sqlalchemy.ext.asyncio import AsyncSession

from backend.api.deps import db_session
from backend.services.crud import user_crud
from backend.schemas.user import UserCreate, UserSchema
from backend.core.config import settings
from backend.api.auth_utils import verify_telegram_auth, is_payload_fresh

logger = logging.getLogger(__name__)

router = APIRouter()

# –ê–¥–º–∏–Ω—Å–∫–∏–µ ID –∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫
ADMIN_TELEGRAM_IDS = settings.ADMIN_TELEGRAM_IDS


@router.post("/login", response_model=UserSchema)
async def login(
    response: Response,
    payload: Dict[str, Any],
    db: AsyncSession = Depends(db_session),
):
    logger.info("üîë –ü–æ–ø—ã—Ç–∫–∞ –ª–æ–≥–∏–Ω–∞ —á–µ—Ä–µ–∑ Telegram-payload: %s", payload)

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ hash
    if not verify_telegram_auth(payload):
        logger.warning("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π hash –æ—Ç Telegram: %s", payload.get("hash"))
        raise HTTPException(400, "Invalid Telegram hash")

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–≤–µ–∂–µ—Å—Ç–∏
    if not is_payload_fresh(payload, window=300):
        logger.warning("‚ùå –£—Å—Ç–∞—Ä–µ–≤—à–∏–π auth_date: %s", payload.get("auth_date"))
        raise HTTPException(400, "Expired Telegram login")

    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
    try:
        tg_id = int(payload["id"])
        tg_username = payload.get("username", "")
    except (KeyError, ValueError):
        raise HTTPException(400, "Telegram ID –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω")

    user_in = UserCreate(telegram_id=tg_id, username=tg_username)
    existing = await user_crud.get_by_telegram_id(db, telegram_id=tg_id)

    if existing is None:
        is_admin = tg_id in ADMIN_TELEGRAM_IDS
        user_obj = await user_crud.create(
            db, obj_in=user_in, extra_fields={"is_admin": is_admin}
        )
        logger.info("‚úÖ –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: %s", user_obj.username)
    else:
        user_obj = existing
        logger.info("üîÑ –£–∂–µ –≤ –ë–î: %s", user_obj.username)

    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ cookie –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    response.set_cookie(
        "tg_id",
        str(tg_id),
        httponly=True,
        secure=False,  # –í –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ –º–µ–Ω—è–µ–º –Ω–∞ True –ø—Ä–∏ HTTPS
        samesite="lax",
        max_age=7 * 24 * 3600,
    )

    return user_obj


async def get_current_user(
    tg_id: str | None = Cookie(None, alias="tg_id"),
    db: AsyncSession = Depends(db_session),
) -> UserSchema:
    if tg_id is None:
        raise HTTPException(401, "–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
    try:
        tg_id_val = int(tg_id)
    except ValueError:
        raise HTTPException(401, "–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π tg_id –≤ cookie")

    user = await user_crud.get_by_telegram_id(db, telegram_id=tg_id_val)
    if user is None:
        raise HTTPException(401, "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω")
    return user


@router.get("/me", response_model=UserSchema)
async def read_own_profile(current_user: UserSchema = Depends(get_current_user)):
    return current_user
